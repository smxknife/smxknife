## 算法

### 算法分析

对于大多数程序，得到其运行时间的数学模型所需要的步骤如下：
* 确定输入模型，定义问题的规模
* 识别内循环
* 根据内循环中的操作确定成本模型
* 对于给定的输入，判断这些操作的执行频率

e.g. 对二分法进行算法分析

> 输入模型是大小为N的数组a[]

> 内循环是一个while循环中所有的语句

> 成本模型是比较操作（比较两个数组元素的值）

> 比较次数最多为lgN+1

算法分析常见的函数

描述|记号|定义
----|----|----
向下取整|⎣x⎦|不大于x的最大整数
向上取整|⎡x⎤|不小于x的最小整数
自然对数|lnN|loge^N(e^x=N)
以2为底的对数|lgN|log2^N(2^X=N)
以2为底的整型对数|⎣lgN⎦|不大于lgN的最大整数，（N的二进制表示位数）-1
调和级数|H_n|1+1/2+1+1/3+...+1/N
阶乘|N!|1×2×3×...×N

算法分析函数常用的近似函数

描述|近似函数
---|---
调和级数求和|H_n ~ lnN
等差数列求和| 1+2+3+...+N ~ N^2/2
等比数列求和| 1+2+4+8+...+N = 2N-1 ~ 2N，其中N=2^n
斯特灵公式|lgN!=lg1+lg2+lg3+...+lgN ~ NlgN
二项式系数|(N, K) ~ N^k/K!(其中k为最小常熟)
指数函数|(1-1/x)^x ~ 1/e

#### 增长数量级的分类

* 常数级别
* 对数级别
* 线性级别
* 线性对数级别
* 平方级别
* 立方级别
* 指数级别

##### 常数级别

    增长数量级为1
    
典型的代码：普通的语句，eg. 将两个数相加
```java
a = b + c;
```

##### 对数级别

    增长数量级log N
    
典型代码：二分法查找

##### 线性级别

    增长的数量级为N
   
典型的代码：循环，eg. 找出最大元素
```java
double max = a[0];
for (int i = 1; i < N; i++) {
	if (a[i] > max) max = a[i];
}
```

##### 线性对数级别
    增长的数量级为 N log N
    
典型的代码：分治，归并排序

##### 平方级别
    增长的数量级为N^2
    
典型代码：双层循环，eg. 检查所有元素
```java
for (int i = 0; i < N; i++) {
	for (int j = i+1; j < N; j++) {
		if (a[i] + a[j] == 0) {
			cnt++;
		}
	}
}
```

##### 立方级别
    增长的数量级为N^3
    
典型代码：三层循环，eg. 检查所有三元组
```java
for (int i = 0; i < N; i++) {
	for (int j = i+1; j < N; j++) {
		for (int k = j+1; k < N; k++) {
			if (a[i] + a[j] + a[k] == 0) {
				cnt++;
			}
		}
	}
}
```

##### 指数级别
    增长数量级为2^N
典型代码：穷举查找，eg. 检查所有子集

#### 倍率定理

    如果T(N) ~ aN^blgN，那么T(2N)/T(N) ~ 2^b

一般来说，数学模型中对数项是不能忽略的，但在倍率假设中它在预测性能的共始终的作用不那么重要
